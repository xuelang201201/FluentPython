1. 键必须是可散列的
一个可散列的对象必须满足以下要求。
（1）支持 hash() 函数，并且通过 __hash__() 方法所得到的散列值是不变的。
（2）支持通过 __eq__() 方法来检测相等性。
（3）若 a == b 为真，则 hash(a) == hash(b) 也为真。

2. 字典在内存上的开销巨大
如果需要存放数量巨大的记录，那么放在由元组或是具名元组构成的列表中会是比较好的选择。
用元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的空间，其二是无需把记录中字段的名字在每个元素里都存放一遍。

3. 键查询很快
dict 的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无视数据量大小的快速访问——只要字典能被装在内存里。

4. 键的次序取决于添加顺序
当往 dict 里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置。于是下面这种情况就会发生：
由 dict([(key1, value1), (key2, value2)]) 和 dict([(key2, value2), (key1, value1)])得到的两个字典，
在进行比较的时候，它们是相等的；但是如果在 key1 和 key2 被添加到字典里的过程中有冲突发生的话，
这两个键出现在字典里的顺序是不一样的。

5. 往字典里添加新键可能会改变已有键的顺序
无论何时往字典里添加新的键，Python 解释器都有可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，
并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。要注意的是，
上面提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，因此你不能很自信地说自己知道背后发生了什么。
如果在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很可能会跳过一些键——甚至是跳过那些字典中已经有的键。

